package SISv6.Components.Gesture;

import SISv6.Utils.BasicComponent;
import SISv6.Utils.KeyValueList;
import SISv6.Utils.MsgEncoder;
import com.rabbitmq.client.Address;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.TimeoutException;

public class GestureComponent extends BasicComponent {
    private int refreshRate = 1000;
    private Date startDate = new Date(), endDate = new Date();
    private Timer timer = new Timer();

    // shared by all kinds of alerts that can be generated by this component
    private KeyValueList alert = new KeyValueList();

    private Queue<String> mockupData;

    public class ComponentRunner extends TimerTask{
        private Date endDate;
        private GestureReading reading = new GestureReading();
        private KeyValueList alert;
        private MsgEncoder encoder;
        private Queue<String> mockupData;

        public ComponentRunner(Date endDate, KeyValueList alert, MsgEncoder encoder, Queue<String> mockupData) {
            this.endDate = endDate;
            this.alert = alert;
            this.encoder = encoder;
            this.mockupData = mockupData;
        }

        @Override
        public void run() {
            if (System.currentTimeMillis() - this.endDate.getTime() > 0) {
                cancel();
            } else {
                componentTask();
            }
        }
        private void componentTask(){
            try {
                collect();
                if (this.reading.needHelp) {
                    //send alert to Controller and Uploader
                    this.reading.date = System.currentTimeMillis();
                    this.alert.putPair("NeedHelp", this.reading.needHelp+"");
                    this.alert.putPair("Date",this.reading.date+"");
                    this.alert.putPair("Receiver","SuperController");
                    this.encoder.sendMsg(this.alert);
                    System.out.println(this.alert.toString());
                } else {
                    System.out.println("=== Patient doesn't need help. ===");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        private void collect() throws Exception {
            if(this.mockupData == null){
                this.mockupData = new LinkedList<>();
                //read in data
                File dataFile = new File("mockup/mockup.txt");
                FileReader fr = new FileReader(dataFile);
                BufferedReader br = new BufferedReader(fr);
                String line;
                while((line = br.readLine()) != null){
                    if(line.startsWith("#")) continue; //line start with # is comment line
                    if(!line.contains("\t")) continue; //lines don't contain \t are invalid
                    this.mockupData.offer(line);
                }
                collect();
            }else if (this.mockupData.size() != 0){
                //read one record
                String[] parts = this.mockupData.poll().split("\t");
                //record format:
                //parts[0]: date in long
                //parts[1]: gesture detected or not in boolean
                try {
                    this.reading.date = Long.parseLong(parts[0]);
                    this.reading.needHelp = Boolean.parseBoolean(parts[1]);
                }catch (Exception e) {
                    System.err.println("parsing mockup data failed");
                }
            }else{
                System.out.println("==== mockup data is used up ====");
            }
        }
    }

    public GestureComponent(String MQ_HOST, String COMPONENT_QUEUE_NAME, String SIS_QUEUE_NAME, String SCOPE, String NAME, List<String> TYPES) throws IOException, TimeoutException {
        super(MQ_HOST, COMPONENT_QUEUE_NAME, SIS_QUEUE_NAME, SCOPE, NAME, TYPES);
        this.initAlert();
    }
    public GestureComponent(Address[] MQ_HOST_List, String COMPONENT_QUEUE_NAME, String SIS_QUEUE_NAME, String SCOPE, String NAME, List<String> TYPES) throws IOException, TimeoutException {
        super(MQ_HOST_List, COMPONENT_QUEUE_NAME, SIS_QUEUE_NAME, SCOPE, NAME, TYPES);
        this.initAlert();
    }


    public void initAlert() {
        this.alert.putPair("Scope", this.SCOPE);
        this.alert.putPair("MessageType", "Alert");
        this.alert.putPair("Sender", this.NAME);
        this.alert.putPair("Purpose", "GestureAlert");
    }
    @Override
    public void ProcessMsg(KeyValueList kvList) throws Exception {
        String scope = kvList.getValue("Scope");
        if (!this.SCOPE.startsWith(scope)) {
            return;
        }
        String messageType = kvList.getValue("MessageType");
        if (!this.TYPES.contains(messageType)) {
            return;
        }
        String sender = kvList.getValue("Sender");
        String receiver = kvList.getValue("Receiver");
        String purpose = kvList.getValue("Purpose");

        switch (messageType) {
            case "Confirm":
                System.out.println("Connect to SISServer successful.");
                break;
            case "Setting":
                if (receiver.equals(NAME)) {
                    System.out.println("Message from " + sender);
                    System.out.println("Message type: " + messageType);
                    System.out.println("Message Purpose: " + purpose);
                    switch (purpose) {
                        case "Activate":
                            String rRate = kvList.getValue("RefreshRate");
                            String sDate = kvList.getValue("StartDate");
                            String eDate = kvList.getValue("EndDate");

                            if (rRate != null && !rRate.equals("")) {
                                this.refreshRate = Integer.parseInt(rRate);
                            }

                            if (sDate != null && !sDate.equals("") && eDate != null
                                    && !eDate.equals("")) {
                                this.startDate.setTime(Long.parseLong(sDate));
                                this.endDate.setTime(Long.parseLong(eDate));
                            }

                            try {
                                this.timer.cancel();
                                this.timer = new Timer();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            this.timer.schedule(new ComponentRunner(this.endDate, this.alert, this.encoder, this.mockupData), this.startDate, this.refreshRate);
                            System.out.println("Algorithm Activated");
                            break;

                        case "Kill":
                            try {
                                this.timer.cancel();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            System.exit(0);
                            break;

                        case "Deactivate":
                            try {
                                this.timer.cancel();
                            } catch (Exception e) {
                                // TODO: handle exception
                            }
                            System.out.println("Algorithm Deactivated");
                            break;
                    }
                }
                break;
        }
    }
}